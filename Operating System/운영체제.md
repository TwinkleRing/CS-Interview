# 운영체제

### 1. 프로그램과 프로세스의 차이

Program은 파일 시스템(하드 디스크, SSD)에 저장되어 존재하는 실행 파일(실행코드와 데이터).

Process는 Program이 실행되어 실제 메모리 상에 적재되고 CPU를 할당받아 실행되고 있는 상태.


### 2. 프로세스와 스레드

프로세스는 메모리 상에서 실행중인 프로그램의 인스턴스(독립적인 개체)이다.

스레드란,  이 프로세스 내의 독립적인 실행 흐름의 단위를 말한다.


프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 가진다.

그러므로 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.

스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위로 
프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data,Heap 영역은 공유한다.


### 3. 프로세스의 주소 공간

#### 프로그램이 CPU에 의해 실행되면 프로세스가 되고 Memory에는 "프로세스 주소 공간"이 할당(생성)된다. </br>
프로세스 주소 공간에는 Code, Data, Stack으로 구성되어 있다.

- Code Segment : 프로그램의 소스 코드가 저장되어있다. 소스 코드는 변경되면 안되므로 읽기만 가능하다. 
- Data Segment : 전역 변수(Global variables)가 저장되어 있다.  함수의 바깥에 있는 전역 변수를 저장하는데 변수는 변할 수 있으므로 읽고 쓰기가 가능하다.
- Stack Segment : 함수, 지역 변수가 저장된다. 지역 변수는 변할 수 있으므로 읽고 쓰기가 가능하다.

#### 구역을 나눈 이유!
=> 최대한 데이터를 공유하여 메모리 사용량을 줄여야 합니다.

1. Code Segment </br>
: 프로그램의 소스 코드는 프로그램이 만들어지고나서 바뀔 일이 없다. 따라서 읽기만 가능한 Read Only 부분입니다. </br>
그렇기 때문에 같은 프로그램을 실행시켜 몇 개의 프로세스가 실행되더라도 같은 프로그램을 실행시킨 것이기에 Code 부분은 다 같은 내용을 가지고 있게 됩니다.
따라서 같은 프로그램의 프로세스일 경우 Code 부분을 공유하여 메모리 사용을 줄이는 목적입니다.

2. Stack Segment </br>
: Stack은 후입선출(Last in First out) 구조입니다.
C언어를 예로 들면 함수의 호출이 이런 Stack 구조의 특성을 활용하였기에 </br> Stack Segment로 나누어 따로 관리합니다. </br>

![image](https://user-images.githubusercontent.com/43642411/104469742-2ffa8980-55fc-11eb-93bf-6a7e1fddd415.png)

![image](https://user-images.githubusercontent.com/43642411/104470666-4c4af600-55fd-11eb-99eb-f90b56acdaf6.png)

3. Data Segment </br>
: 전역 변수는 어떤 함수에서도 접근할 수 있기 때문에 Data Segment로 따로 관리를 하여 메모리를 아낄수 있습니다.


참고 사이트 : https://whereisusb.tistory.com/10


### 4. Context Switching
프로세스가 실행되다가 인터럽트가 발생하여 운영체제에 의해 CPU(프로세서)가 할당된 프로세스를 바꾸는 것을 말한다.

프로세서가 다른 프로세스로 스위치할 때 시스템은 현재 작업중인 프로세스의 상태(Context)를 저장하고 새로운 프로세스의 상태를 로드한다.

### 5. 멀티 프로세스 VS 멀티 쓰레드


+ 멀티 프로세스는 다수의 프로세스를 실행하는 것이다. fork를 통해 프로세스를 복사하여 사용하는데, </br> 부모와 자식 관계라 해도 프로세스마다 독자적인 메모리 영역을 가진다.

+ 멀티 쓰레드는 단일 프로세스에서 여러 개의 스레드가 병행적으로 처리되는 것을 말한다.

멀티 프로세스와 멀티 쓰레드 모두 동시에 두 가지 이상의 루틴을 실행 할 수 있는 역할을 한다.

---
> ####  멀티 프로세스
- 장점 : 여러 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다.
- 단점 : 여러 프로세스가 실행될 때 CPU에서는 문맥교환(Context Switching)이 발생하므로 이때 성능 저하가 발생한다. </br> 또한 프로세스 간에 데이터를 주고 받을 때 복잡하고 비용이 비싼 IPC(Inter Process Communication)을 사용해야한다.

> ####   멀티 쓰레드
- 장점 : 다른 쓰레드와 Stack을 제외한 Code, Data, Heap 영역의 자원을 공유하여 메모리 낭비, 문맥 교환에 소비되는 시간도 감소한다.
  </br>프로세스 간 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소한다.
  </br>프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능하다.
- 단점 : 자원을 공유하므로 동기화 문제가 발생하고 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.



### 6. 교착상태(Dead Lock)

#### 교착 상태란. 다중 프로그래밍 환경에서 여러 프로세스가 한정된 자원을 사용하기 위해 경쟁하고 있으며,
한 프로세스가 자원을 사용하려 할때 해당 자원을 얻지 못해 다음 처리를 하지 못하는 상태를 말합니다.
시스템적으로 한정된 자원을 여러 프로세스가 사용하려고 할 때 발생하는 문제로 교착상태가 발생하는 4가지 조건이 있습니다.

##### 1. 상호배제 |  한번에 한개의 프로세스만이 공유 자원을 사용할 수 있어야 합니다.
---
##### 2. 점유와 대기(Hold and Wait) |  최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야합니다.
---
##### 3. 비선점(Non-preemption) |  다른 프로세스에 할당된 자원은 사용이 끝날때 까지 강제로 빼앗을 수 없어야합니다.
---
##### 4. 순환 대기(Circular Wait) |  공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 합니다.

---
순환대기는 점유와 대기, 비선점을 모두 만족해야 성립합니다.

### 7. 교착상태 처리 기법




### 8. 뮤텍스 & 세마포어

##### 임계 구역(Critical Section) : 여러 프로세스가 자원을 공유하며 수행 될 때, 각 프로세스에서 공유 자원을 접근하는 프로그램 코드 부분 </br> 공유 자원을 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법
병행 처리를 위한 프로세스 동기화 기법

#### Mutex(뮤텍스)
> 뮤텍스는 자원에 대한 접근을 동기화하기 위해 사용되는 상호배제 기법이다. </br> 뮤텍스는 Binary Semaphore와 같이 초기 값으로 0과 1 을 가집니다. </br>뮤텍스는 Locking 메커니즘으로 오직 하나의 쓰레드만이 동일한 시점에 뮤텍스를 얻어 임계 영역(Critical Section)에 들어올 수 있습니다. </br>그리고 오직 이 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.


#### Semaphore(세마포어)
> 세마포어는 Signaling 메커니즘이라는 점에서 뮤텍스와 다릅니다. 세마포어는 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있다는 점에서, wait 함수를 호출한 쓰레드만이 signal 함수를 호출할 수 있는 뮤텍스와 다릅니다. </br> 세마포어는 동기화를 위해 wait와 signal이라는 2개의 atomic operations를 사용합니다. </br> wait를 호출하면 세마포어의 카운트를 1 줄이고, 세마포어의 카운트가 0 보다 작거나 같아질 경우에 락이 실행됩니다.</br> 
세마포어는 단순한 정수 변수로, 세마포어가 0이라면 이미 제한된 수의 프로세스가 Critical Section에 접근하고 있는 상태이므로,</br> 세마포어가 1 이상이 될 때까지 임계구역에 접근하는 다른 프로세스들은 대기하게 됩니다. </br> 세마포어가 1 이상의 수라면 다른 프로세스가 임계구역에 접근할 수 있습니다.






### 9. 캐시(Cache)

캐시 메모리는 속도가 빠른 저장 장치와 느린 저장 장치 상의 속도 차이에 따른 병목 현상을 줄이기 위해 사용하는 범용 메모리이다.
캐시의 성능(Hit rate)를 높이기 위해 데이터 지역성(Locality)을 이용하여 CPU가 어떤 데이터를 원할 것인가를 어느 정도 예측하여 캐시 메모리에 데이터를 저장한다.

#### 지역성(Locality)은 프로세스들이 기억장치 내의 데이터를 균일하게 접근하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성.</br>그리고 메모리의 위치와 접근 시간에 따라서 공간적, 시각적 특성을 보인다.

#### 시각 지역성(Spatial Locality) : 최근에 참조된 주소의 내용은 곧 재참조될 가능성이 높은 특성.
>대표적인 예로 반복문(for, while)이 있다. 반복문을 수행하면 특정 메모리 값으로 선언된 부분을 반복하여 접근하게 된다. 

---

#### 공간 지역성(Temporal Locality) : 최근에 참조된 메모리 주소에 인접한 데이터가 참조될 가능성이 높은 특성
>예를 들어, 배열(Array)을 생각해보면 이 Array는 일정한 메모리 공간을 순차적으로 할당받아 사용한다. 공간 할당을 연속적으로 받게 되는 것이다.
C언어에서 int a[10] 이라고 선언을 하고 프로그램 중간에서 a[0]를 사용하면 같은 배열의 인접한 a[1]도 잠시 후에 사용될 확률이 높다는 것이다.



#### 캐시 히트와 캐시 미스 
CPU에서 필요로 하는 데이터가 캐시 메모리에 있어서 이 데이터를 참조할 수 있느냐는 것이 캐시 메모리의 성능이 된다.
이때 CPU가 필요로 하는 데이터가 캐시 메모리 내에 존재하면 'Cache Hit'라 하고, 없는 경우를 'Cache Miss'라 한다.



