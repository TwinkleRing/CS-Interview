# CPU 스케줄링 알고리즘


### CPU 스케줄링의 필요성

CPU 스케줄링은 CPU를 사용하는 패턴이 서로 다른 여러 프로그램이 동일한 시스템에서 함께 실행되기 때문에 필요합니다.<br>
만약 프로세스의 CPU Burst가 모두 균일한 경우에는 CPU 스케줄링을 사용하는게 큰 의미가 없을 것입니다.<br>
그러나 우리가 사용하는 시분할 시스템에서는 이와 같이 CPU Burst가 균일하지 않은 다양한 프로그램이 존재하기 때문에, <br>
효율적인 CPU 스케줄링 기법이 반드시 필요합니다.

대부분의 프로세스들의  CPU Burst는 대부분 짧은  CPU Burst를 가지며 극히 일부분만 긴  CPU Burst를 가집니다.<br>
다시 말해 CPU를 한번에 오래 사용하기 보다 잠깐 사용하고 I/O(입출력) 작업을 수행하는 프로세스들이 많다는 뜻입니다. <br>
그러므로 CPU 스케줄링을 할 때  CPU Burst가 짧은 프로세스들에게 우선적으로 CPU를 사용하게 해주면 더 효율적이게 됩니다.

---

###  Scehduling Criteria(성능 척도)

1. **CPU 사용량(CPU utilization)** : 시간 당 CPU를 사용한 시간의 비율
  * CPU를 실행상태로 항상 유지하여 유휴상태가 되지 않도록 한다. 
  * 가능하면 입출력 중심의 작업보다 프로세서 중심의 작업을 실행해야한다.
  
2. **Throughput(처리율)**
  * 단위 시간 당 처리한 프로세스의 수
  * 단위 시간당 완료되는 작업 수가 많도록 짧은 작업을 우선 처리하거나 인터럽트 없이 작업을 실행한다.
  
3.  **Turnaround time(반환 시간)**
  * 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간이다.
  * 하나의 프로세스가 레디 큐에서 대기한 시간부터 작업을 마칠 때까지 걸리는 시간.
  
4.  **Waiting Time (대기 시간)*8
  * 프로세스가 준비 큐에 들어와 CPU를 할당받기 까지 대기한 시간
  * 준비 큐에서 대기하는 시간이 최소가 되도록 해야한다.
  
5.  **Response Time(응답 시간)**
  * 프로세스가 처음으로 CPU를 할당받기까지 걸린 시간

---

## CPU Scheduling Algorithm
CPU 스케줄링 알고리즘은 준비 큐에 있는 프로세스를 대상으로 다음에 어떤 작업을 CPU에 할당할 것인지를 정하는 알고리즘입니다.

* 비선점형(Nonpreemptive) : CPU를 획득한 프로세스가 스스로 CPU를 반납하기 전까지 CPU를 빼앗기지 않는 방법.
* 선점형(Preemptive) : 프로세스가 CPU를 계속 사용하기를 원하더라도 강제로 빼았을 수 있는 스케줄링 방법. (= 타이머 인터럽트 방식)

### 1. FCFS(First Come First Served)

#### 특징 
 * 프로세스가 준비 큐에 도착한 시간 순서대로 CPU 할당을 처리하는 방식
 * 비선점형 스케줄링 방법으로 일단 먼저 온 프로세스가 CPU를 잡으면 CPU Burst가 완료될 때까지 CPU를 반환하지 않는다.
 
#### 문제점
 * Convoy Effect :  CPU Burst가 긴 프로세스가 먼저 도달할 경우 평균 대기 시간이 길어지고 효율이 떨어지는 현상

---

### 2. SJF(Shortest - Job - First)

#### 특징 
 * 다른 프로세스가 먼저 준비 큐에 도착했어도 CPU burst time이 더 짧은 프로세스에게 먼저 CPU를 할당하는 방법.
 * - 비선점형 : 일단 CPU를 할당받으면 그 프로세스가 CPU를 자진 반납하기 전까지 CPU를 선점당하지 않는 방식
 * - 선점형 : 현재 CPU에서 실행중인 프로세스의 남은 CPU burst time보다 더 짧은 CPU burst를 가지는 프로세스가 도착하면 CPU를 빼앗게 됩니다. <br>
              일반적인 시분할 환경에서는 중간 중간에 새로운 프로세스가 도착하는 경우가 발생하므로 선점형 방식이 평균 대기시간을 가장 많이 줄일 수 있는 방식이 됩니다. <br>
              SJF를 선점형 구현 방식을 SRTF(Shortest Remaining Time First)라고 합니다. 
 
#### 문제점
 * Starvation(기아현상) :  SJF 스케줄링 방식은 CPU burst time이 짧은 프로세스에게 집중되어 있다.
                CPU burst time이 긴 프로세스는 계속해서 CPU burst time이 짧은 프로세스에 밀려 CPU를 영원히 할당받지 못하는 상황이 발생한다.

---

### 3. SRTF & SRF(Shortest Remaining Time First)

#### 특징 
 * 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
 * SJF 스케줄링의 **선점형** 방법
 * 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다.
 
#### 문제점
 * Starvation
 * 새로운 프로세스가 도착할 때마다 스케줄링을 다시하기 때문에 CPU 사용 시간(burst time)을 정확히 예측하기 어렵다.
 
---
 
### 4. Priority Scheduling

#### 특징 
 * 우선순위가 가장 높은 프로세스에게 CPU 를 할당하는 스케줄링이다. (우선 순위란 정수로 표현, 작을수록 우선 순위가 높다)
 * 선점형 : 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.
 * 비선점형 : 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 맨 앞으로 둔다.
 
#### 문제점
 * Starvation (기아 현상)
 * 무기한 봉쇄 : 실행 준비는 마쳤으나 우선순위가 낮은 프로세스들이 CPU 할당을 무기한 대기하는 상태
 
#### 해결책 
* Aging(에이징 기법) : 아무리 우선 순위가 낮은 프로세스라도 오래 대기하면 우선 순위를 점진적으로 높여준다.

---
 
### 5. Round Robin

#### 특징 
 * 가장 현대적인 CPU 스케줄링으로 시분할 시스템을 위해 설계되었다.
 * 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 된다.
 * 할당 시간이 지나면 프로세스는 인터럽트가 발생하여 CPU를 반납하고 준비 큐의 제일 뒤에 가서 다시 줄을 선다
 * Response time이 짧아지는 장점이 있다.
 * CPU Burst Time이 랜덤한 프로세스들이 많은 때 가장 효율적인 스케줄링 방식이다.
 
#### 주의할 점
 * 할당 시간(time quantum)이 너무 작으면 계속되는 Context Switch로 오버헤드가 발생한다.
 

 
